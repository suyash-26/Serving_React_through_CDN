Go to child-app build folder in terminal and run following commands
   npm install -g http-server
   http-server --cors -p 5173


###  Q1- Is file structure of build and dist folder different? 

>>> Yes, the file structure of the `build` and `dist` folders can be different, depending on the tools and configurations used to generate them. Here are the common distinctions:

1. **`build` Folder:**
   - Typically associated with tools like Create React App (CRA).
   - Contains the output of a production build, including minified JavaScript and CSS files.
   - Includes an `index.html` file, static assets like images, and other resource files.
   - Structure might look like this:
     ```
     build/
     ├── static/
     │   ├── css/
     │   │   └── main.<hash>.css
     │   ├── js/
     │   │   ├── main.<hash>.js
     │   │   └── runtime~main.<hash>.js
     │   └── media/
     │       └── logo.<hash>.svg
     ├── index.html
     ├── manifest.json
     └── service-worker.js
     ```

2. **`dist` Folder:**
   - Typically associated with bundlers like Webpack, Rollup, or Parcel, as well as with frameworks like Vite.
   - Contains the output of the bundling process, often customized based on the project's configuration.
   - May include multiple JavaScript bundles, CSS files, and assets.
   - Structure can vary significantly but might look like this:
     ```
     dist/
     ├── assets/
     │   ├── logo.<hash>.svg
     │   ├── styles.<hash>.css
     │   └── script.<hash>.js
     ├── index.html
     └── manifest.json
     ```

### Key Differences:

1. **Naming and Hashing:**
   - Both folders may use hashed filenames for cache busting, but the naming conventions and structures can vary based on the tool and configuration used.

2. **Folder Structure:**
   - The structure of the `build` folder is usually more opinionated and consistent with tools like CRA, whereas the `dist` folder can be highly customized depending on the project's setup with tools like Webpack or Vite.

3. **Generated Files:**
   - The `build` folder might include service workers or other files specific to single-page applications (SPA), while the `dist` folder can be tailored for different types of applications, including libraries.

4. **Customization:**
   - The `dist` folder often provides more flexibility in terms of customization and optimization settings, whereas the `build` folder generated by CRA follows a specific convention designed for simplicity and best practices in React applications.

### Example Scenarios:

- **Create React App (CRA):** Generates a `build` folder with a specific structure optimized for React applications.
- **Vite:** Generates a `dist` folder with a structure that can be customized based on the project's configuration in `vite.config.js`.
- **Webpack/Rollup:** Generates a `dist` folder with a structure that is highly dependent on the project's webpack or rollup configuration.

### Conclusion:

The exact structure of the `build` and `dist` folders depends on the tools and configurations used in your project. While there are common patterns, the specifics can vary based on how you set up your build process.

<br><br><br>

### Q2-How can i serve my build folder locally?

>>> To serve your `build` folder locally, you can use various tools and methods. Here are a few popular options:

### Using `http-server` (Node.js)

1. **Install `http-server`:**
   ```bash
   npm install -g http-server
   ```

2. **Serve the `build` folder:**
   Navigate to your project directory where the `build` folder is located and run:
   ```bash
   http-server build
   ```

3. **Access your site:**
   Open your browser and go to `http://localhost:8080` (the default port).

### Using `live-server` (Node.js)

1. **Install `live-server`:**
   ```bash
   npm install -g live-server
   ```

2. **Serve the `build` folder:**
   Navigate to your project directory where the `build` folder is located and run:
   ```bash
   live-server build
   ```

3. **Access your site:**
   Open your browser and go to the URL displayed in the terminal (usually `http://127.0.0.1:8080`).

### Using Python (if you have Python installed)

1. **Navigate to your `build` folder:**
   ```bash
   cd build
   ```

2. **Serve the folder using Python's built-in HTTP server:**

   - **Python 3:**
     ```bash
     python -m http.server 8000
     ```

   - **Python 2:**
     ```bash
     python -m SimpleHTTPServer 8000
     ```

3. **Access your site:**
   Open your browser and go to `http://localhost:8000`.

### Using VS Code Live Server Extension

1. **Install the Live Server extension:**
   Install the Live Server extension from the Visual Studio Code marketplace.

2. **Open your project in VS Code:**
   Open your project folder in Visual Studio Code.

3. **Start Live Server:**
   Right-click on the `build` folder in the VS Code explorer and select `Open with Live Server`. This will start a local server and open your project in the default web browser.

### Using Serve (Node.js)

1. **Install `serve`:**
   ```bash
   npm install -g serve
   ```

2. **Serve the `build` folder:**
   Navigate to your project directory where the `build` folder is located and run:
   ```bash
   serve -s build
   ```

3. **Access your site:**
   Open your browser and go to the URL displayed in the terminal (usually `http://localhost:5000`).

These methods will allow you to serve your `build` folder locally and view your application in the browser.

<br><br><br>

### Q3- How can i access this bulid folder served on some port in parent app? ( iframe is interesting one😁 ) 

>>> To access a `build` folder served on a specific port in a parent application, you need to consider how the parent application and the served `build` folder interact. Here are a few common scenarios and their solutions:

### Scenario 1: Accessing via an Iframe
If you want to embed the served application within another web application, you can use an iframe.

1. **Serve the `build` folder:**
   As mentioned earlier, serve your `build` folder using `http-server`, `live-server`, `python`, etc.

2. **Embed using an iframe:**
   In your parent application's HTML or JSX (if using React), embed the served application using an iframe.

   ```html
   <iframe src="http://localhost:5000" width="100%" height="100%"></iframe>
   ```

   This will load the application served on `http://localhost:5000` within an iframe in the parent application.

### Scenario 2: Fetching Data from the Served Application
If your `build` folder serves an API, you can make HTTP requests to the served application from your parent application.

1. **Serve the `build` folder:**
   Serve your `build` folder using `http-server`, `live-server`, `python`, etc.

2. **Make HTTP requests:**
   Use `fetch`, `axios`, or another HTTP client to make requests to the served application's API.

   ```javascript
   fetch('http://localhost:5000/api/endpoint')
     .then(response => response.json())
     .then(data => console.log(data))
     .catch(error => console.error('Error:', error));
   ```

### Scenario 3: Proxying Requests in a Development Environment
If your parent application is also a Node.js/React application, you can configure a proxy to redirect requests to the served `build` folder.

1. **Serve the `build` folder:**
   Serve your `build` folder using `http-server`, `live-server`, `python`, etc.

2. **Configure a proxy in the parent application:**
   If using Create React App, add a `proxy` field to your `package.json`:

   ```json
   {
     "proxy": "http://localhost:5000"
   }
   ```

   Now, any unrecognized requests (like `/api/endpoint`) will be proxied to `http://localhost:5000`.

### Example with Create React App

Assuming your parent application is created with Create React App:

1. **Serve the `build` folder:**
   ```bash
   npx serve -s build -l 5000
   ```

2. **Set up proxy in `package.json` of the parent app:**
   ```json
   {
     "name": "parent-app",
     "version": "0.1.0",
     "private": true,
     "dependencies": {
       "react": "^17.0.2",
       "react-dom": "^17.0.2",
       "react-scripts": "4.0.3"
     },
     "scripts": {
       "start": "react-scripts start",
       "build": "react-scripts build",
       "test": "react-scripts test",
       "eject": "react-scripts eject"
     },
     "proxy": "http://localhost:5000"
   }
   ```

3. **Fetch data in your React component:**
   ```javascript
   import React, { useEffect, useState } from 'react';

   function App() {
     const [data, setData] = useState(null);

     useEffect(() => {
       fetch('/api/endpoint')
         .then(response => response.json())
         .then(data => setData(data))
         .catch(error => console.error('Error:', error));
     }, []);

     return (
       <div className="App">
         <header className="App-header">
           <h1>Parent App</h1>
           {data && <pre>{JSON.stringify(data, null, 2)}</pre>}
         </header>
       </div>
     );
   }

   export default App;
   ```

### Conclusion
The exact method you choose depends on how you want to interact with the served `build` folder. Using iframes is a simple way to embed another application, while fetching data is useful if your `build` folder serves an API. Proxying is convenient in a development setup for seamless integration.

<br><br><br>

### Q4 - How to confirm which is starting file ?  ( To serve the child app build folder on parent-app index.html file using script tag )

>>>To determine the entry point (starting file) of your build directory when serving a React application (or any JavaScript application) that has a nested structure like `static/js/`, you can follow these steps:

### Steps to Find the Entry Point

1. **Inspect the HTML File:**
   The starting file for your React app is typically referenced in the `index.html` file generated by the build process. This file usually includes a `<script>` tag that points to the main JavaScript bundle.

2. **Locate the `<script>` Tag:**
   Open the `index.html` file in your build directory. Look for a `<script>` tag that loads the main JavaScript file. It will typically look something like this:
   ```html
   <script src="/static/js/main.[hash].js"></script>
   ```

3. **Identify the Entry Point:**
   The `src` attribute of this `<script>` tag contains the path to your main JavaScript file. The `main.[hash].js` file is your entry point, where `[hash]` is a unique identifier generated during the build process.

### Example Directory Structure
Here is an example of a typical build directory structure for a React app:

```
build/
├── index.html
├── static/
│   ├── css/
│   └── js/
│       ├── main.[hash].js
│       ├── 2.[hash].js
│       └── runtime-main.[hash].js
```

### Steps to Serve and Include the Script

1. **Serve the Build Directory:**
   Use a static file server like `http-server` to serve your build directory. For example:
   ```bash
   npx http-server build -p 5173 --cors
   ```

2. **Include the Script in Your Parent App:**
   Use the `<script>` tag in your parent app's HTML to include the main JavaScript file. Ensure the path matches the structure of your served files.

### Example Parent HTML File
Assuming the main JavaScript file is `main.[hash].js` located in `static/js/`:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Parent App</title>
</head>
<body>
  <div id="root"></div>
  <script type="module" src="http://127.0.0.1:5173/static/js/main.[hash].js"></script>
</body>
</html>
```

### Handling Dynamic Hash
If the hash is dynamic and changes with each build, you'll need to update the script path accordingly. For development purposes, you can manually copy the correct path from the `index.html` file in the build directory. For production, you might consider automating this process through a build script or configuration.

### Additional Tips

- **Check the Build Output:**
  The `create-react-app` build process (or equivalent) generates the necessary files. Inspect the build output to ensure all assets are correctly referenced.

- **Use Environment Variables:**
  In a more complex setup, you might use environment variables or a configuration file to dynamically set the script path in your parent app.

By following these steps, you can correctly identify and include the entry point script of your React app's build directory in your parent HTML file.

<br><br><br>
